---
title: "Match_SDWIS_ECHO"
author: "Jim Sheehan"
date: "July 9, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## 0. Load packages

```{r}

library(readr)
library(RPostgreSQL)
library(dplyr)
# library(rebus)
library(stringr)
library(purrr)

# library(DBI)

library(zipcode) # for getting lat/lon coordinates where zipcode is available

```


## I. Load Data

```{r}

#### My Postgres
drv <- dbDriver("PostgreSQL")

con <- dbConnect(drv, dbname = "postgres",
                 host = "localhost", port = 5432,
                 user = "postgres")

# to see schema list (although doesn't show which tables are in them)
dbGetQuery(con, "SELECT nspname FROM pg_catalog.pg_namespace")

# to see list of all tables (no schema though)
dbListTables(con)

echo_sdwis <- 
  dbGetQuery(con, "SELECT * FROM echo.echo_exporter WHERE sdwis_flag = 'Y'")

# active PWS only
water_system <- 
  dbGetQuery(con, "SELECT * FROM sdwis.water_system WHERE pws_activity_code = 'A'")

# active PWS only, use area_type_code = 'CT' & area_type_code = 'ZC' in geocoding
geographic_area <- 
  dbGetQuery(con, "SELECT * FROM sdwis.geographic_area WHERE pws_activity_code = 'A'")

#### My .csv
US_cities <- read_csv("C:/Users/Jim/Files/CFB/data/uscitiesv1_5.csv")

# for easier matching
US_cities$city_ascii_lwr <- tolower(US_cities$city_ascii)

# R zipcode package data, rename columns to help keep info separate
data(zipcode)
colnames(zipcode) <- c("zip", "Rzcpkg_city", "Rzcpkg_state", "Rzcpkg_lat", "Rzcpkg_lon")

```



## II. Reduce echo columns, count sdwa_ids


```{r}
echo_sdwa_ids <- echo_sdwis %>% 
  select(registry_id:fac_county, fac_lat:fac_accuracy_meters, sdwa_ids) %>% 
  mutate(fac_accuracy_meters = as.numeric(fac_accuracy_meters))

## test
# str_count("mmm mmmm mmm", pattern = " ")

# counting space delimiter, + 1
echo_sdwa_ids <- echo_sdwa_ids %>% 
  mutate(sdwa_ids_count = str_count(sdwa_ids, pattern = " ") + 1)

table(echo_sdwa_ids$sdwa_ids_count > 1)

```

*view multiples, appears can do string matching b/c they contain individual ids*

```{r}
echo_sdwa_ids %>% filter(sdwa_ids_count > 1) %>% 
  select(sdwa_ids)

```


## III. Join data

*1 to 1 first*

```{r}

# Using all
watsys_echoloc_1to1 <- water_system %>% 
  left_join(., echo_sdwa_ids, by = c("pwsid" = "sdwa_ids"))

# check unique
length(unique(watsys_echoloc_1to1$pwsid))

# fix for later rbind, add sdwa_ids and rearrange a bit

watsys_echoloc_1to1 <- watsys_echoloc_1to1 %>% 
  mutate(sdwa_ids = pwsid) %>% 
  select(pwsid, sdwa_ids, everything()) %>% 
  mutate(sdwa_ids_type = "single")

# Filtering down to zip code centroid and finer (<= 10000)
watsys_echoloc_1to1_acc01 <- watsys_echoloc_1to1 %>% 
  filter(fac_accuracy_meters <= 10000)

nrow(watsys_echoloc_1to1_acc01)

```

*string matching for single water system pwsid's within multiple echo sdwa's*

```{r}
multi_echo_sdwa_ids <- echo_sdwa_ids %>% 
  filter(sdwa_ids_count > 1) %>% 
  .$sdwa_ids

length(multi_echo_sdwa_ids)

pwsids_noecho <- watsys_echoloc_1to1 %>% 
  filter(is.na(sdwa_ids_count)) %>% 
  .$pwsid

length(pwsids_noecho)

```


```{r}
# loop

n1 <- length(multi_echo_sdwa_ids)

matchlist1 <- list()
for(i in 1:n1){
  
  match <- str_match(multi_echo_sdwa_ids[i], pattern = pwsids_noecho)
  match <- match[which(!is.na(match[,1])),]
  matchlist1[[i]] <- match
  }

names(matchlist1) <- multi_echo_sdwa_ids

# Results Note: this sdwa_idsmatches to multiple pwsids
multi_echo_sdwa_ids[4]; matchlist1[[4]]
# Results Note: this sdwa_ids matches to one pwsids
multi_echo_sdwa_ids[5]; matchlist1[[5]]
```

## stacking pwsids

```{r}
# # potential alternate approach
# library(splitstackshape)
# cSplit

# remove empty list elements (those w/no matches found)
matchlist2 <- compact(matchlist1)

n2 <- length(matchlist2)

matchlist3 <- list()

for(i in 1:n2) {
  items <- cbind(matchlist2[[i]])
  id <- names(matchlist2[i])
  items_id <- cbind(items, id)
  matchlist3[[i]] <- items_id

}

# conversion, tidying up
matchlist3_df <- data.frame(do.call(rbind, matchlist3))
names(matchlist3_df) <- c("pwsid", "sdwa_ids")
matchlist3_df[] <- lapply(matchlist3_df, as.character)

# join this back to water_system (select fields?)
matchlist3_df <- left_join(matchlist3_df, water_system, by = "pwsid")

# create new inner join to echo_sdwa_ids
watsys_echoloc_1toM <- inner_join(matchlist3_df, echo_sdwa_ids, by = "sdwa_ids") %>% 
  mutate(sdwa_ids_type = "multi")


watsys_echoloc_1toM_acc01 <- watsys_echoloc_1toM %>% 
  filter(fac_accuracy_meters <= 10000)

nrow(watsys_echoloc_1toM_acc01)

```


```{r}

watsys_echoloc_I <- bind_rows(watsys_echoloc_1to1_acc01, watsys_echoloc_1toM_acc01)

# check for no duplicates
nrow(watsys_echoloc_I) == length(unique(watsys_echoloc_I$pwsid))

nrow(watsys_echoloc_I)
```


```{r}
NewEngStates <- c("CT", "MA", "ME", "NH", "RI", "VT")

# use epa region so can grab tribal (only 1 of 5 so far)
 
watsys_echoloc_I_NewEng <- watsys_echoloc_I %>% 
  filter(epa_region == "01")
#  filter(primacy_agency_code %in% NewEngStates)

table(watsys_echoloc_I_NewEng$primacy_agency_code)  
  
 
```

*export*
```{r}
watsys_echoloc_I_NewEng %>% 
  select(primacy_agency_code, epa_region, pwsid, pws_type_code,
         fac_lat, fac_long, sdwa_ids, fac_collection_method) %>% 
  arrange(primacy_agency_code, pwsid) %>% 
  mutate(source = "ECHO") %>% 
  select(primacy_agency_code, epa_region, pwsid, pws_type_code,
         fac_lat, fac_long, source, sdwa_ids, fac_collection_method) %>% 
  write_csv(., "data_export/watsys_echoloc_I_NewEng.csv")

```




## now for other coordinate sources
```{r}

watsys_noecholoc_NewEng <- water_system %>% filter(epa_region == "01") %>% 
  anti_join(., watsys_echoloc_I_NewEng, by = "pwsid")

table(watsys_noecholoc_NewEng$primacy_agency_code)

```

1. zip code served (best, but not too many)

```{r}
ga_NewEng_ZC_1x <- geographic_area %>% 
  filter(epa_region == "01", area_type_code == "ZC") %>% 
  group_by(pwsid) %>% 
  summarise(n = n()) %>% 
  filter(n == 1) %>% 
  .$pwsid

ga_NewEng_ZC_1x_df <- geographic_area %>% 
  filter(pwsid %in% ga_NewEng_ZC_1x, area_type_code == "ZC") %>% 
  select(-c(pws_activity_code, pws_type_code, city_served, 
            primacy_agency_code, epa_region, end_column))

# none in New England apparently,
# maybe merge zips and get a centroid eventually for rest of US
ga_NewEng_ZC_Mx <- geographic_area %>% 
  filter(epa_region == "01", area_type_code == "ZC") %>% 
  group_by(pwsid) %>% 
  summarise(n = n()) %>% 
  filter(n > 1) %>% 
  .$pwsid

```

*then join to zipcode dataset*

```{r}
# citation("zipcode")

```


```{r}
sum(nchar(zipcode$zip) != 5) # all 5 character length
sum(nchar(ga_NewEng_ZC_1x_df$zip_code_served) != 5) # all 5 character length

ga_NewEng_ZC_1x_df <- ga_NewEng_ZC_1x_df %>% left_join(., zipcode, 
                                 by = c("zip_code_served" = "zip"))

sum(is.na(ga_NewEng_ZC_1x_df$Rzcpkg_lat)) # all matched

watsys_noecholoc_NewEng_gaZC <- water_system %>% filter(epa_region == "01") %>% 
  inner_join(., ga_NewEng_ZC_1x_df, by = "pwsid")

nrow(watsys_noecholoc_NewEng_gaZC) == length(unique(watsys_noecholoc_NewEng_gaZC$pwsid))
nrow(watsys_noecholoc_NewEng_gaZC)


```

*exclude ECHO already done, as good or maybe better*

```{r}
watsys_noecholoc_NewEng_gaZC2 <- anti_join(watsys_noecholoc_NewEng_gaZC, 
                                          watsys_echoloc_I_NewEng, 
                                          by = "pwsid")
```



*export*
```{r}
watsys_noecholoc_NewEng_gaZC2 %>% 
  select(primacy_agency_code, epa_region, pwsid, pws_type_code,
         Rzcpkg_lat, Rzcpkg_lon, zip_code_served) %>% 
  arrange(primacy_agency_code, pwsid) %>% 
  mutate(source = "R_ZIPCODE") %>% 
  select(primacy_agency_code, epa_region, pwsid, pws_type_code,
         Rzcpkg_lat, Rzcpkg_lon, source, zip_code_served) %>% 
  write_csv(., "data_export/watsys_noecholoc_NewEng_gaZC2.csv")

```


2. 
# Then do CT to city database, but need to clean up city names a bit!


```{r}
ga_NewEng_CT_1x <- geographic_area %>% 
  filter(epa_region == "01", area_type_code == "CT") %>% 
  group_by(pwsid) %>% 
  summarise(n = n()) %>% 
  filter(n == 1) %>% 
  .$pwsid

ga_NewEng_CT_1x_df <- geographic_area %>% 
  filter(pwsid %in% ga_NewEng_CT_1x, area_type_code == "CT") %>% 
  select(-c(pws_activity_code, pws_type_code, zip_code_served, 
            epa_region, end_column))

# may do additional, e.g., ascii-consistent

ga_NewEng_CT_1x_df <- ga_NewEng_CT_1x_df %>% 
  mutate(city_served2 = tolower(str_trim(city_served)))

# exclude any with zipcode served (prob. better)

ga_NewEng_CT_1x_df2 <- anti_join(ga_NewEng_CT_1x_df, ga_NewEng_ZC_1x_df,
                                 by = "pwsid")


# a few in New England apparently,
# maybe get cities lat long average eventually, also for rest of US
ga_NewEng_CT_Mx <- geographic_area %>% 
  filter(epa_region == "01", area_type_code == "CT") %>% 
  group_by(pwsid) %>% 
  summarise(n = n()) %>% 
  filter(n > 1) %>% 
  .$pwsid


```


*then clean city served, join to US_cities dataset*


```{r}

ga_NewEng_CT_1x_df2 <- ga_NewEng_CT_1x_df2 %>% inner_join(., US_cities, 
                                 by = c("primacy_agency_code" = "state_id", 
                                        "city_served2" = "city_ascii_lwr"))


watsys_noecholoc_NewEng_gaCT <- water_system %>% filter(epa_region == "01") %>% 
  inner_join(., ga_NewEng_CT_1x_df2, by = "pwsid")


nrow(watsys_noecholoc_NewEng_gaCT) == length(unique(watsys_noecholoc_NewEng_gaCT$pwsid))
nrow(watsys_noecholoc_NewEng_gaCT)


```

*exclude ECHO already done, maybe better*
```{r}

watsys_noecholoc_NewEng_gaCT2 <- anti_join(watsys_noecholoc_NewEng_gaCT, 
                                          watsys_echoloc_I_NewEng, 
                                          by = "pwsid")

```



*export*
```{r}
watsys_noecholoc_NewEng_gaCT2 %>% 
  select(primacy_agency_code.x, epa_region, pwsid, pws_type_code, 
         lat, lng, city_served2) %>% 
  arrange(primacy_agency_code.x, pwsid) %>% 
  mutate(source = "US_CITIES", comments = "City/Town Coordinates") %>% 
  select(primacy_agency_code.x, epa_region, pwsid, pws_type_code,
         lat, lng, source, city_served2, comments) %>% 
  write_csv(., "data_export/watsys_noecholoc_NewEng_gaCT2.csv")

```


## N so far
```{r}

nrow(watsys_echoloc_I_NewEng)
nrow(watsys_noecholoc_NewEng_gaZC2)
nrow(watsys_noecholoc_NewEng_gaCT2)

```



## got about half

```{r}
water_system %>% filter(epa_region == "01") %>% 
  .$pwsid %>% length()


```



## NH shapefile to fill in some

```{r}
library(sf)

z_NH_centers <- 
  st_read("C:/Users/Jim/Files/CFB/GIS/locations/NH/GRANIT_20190713073323/pbp_centers.shp")

st_crs(z_NH_centers)

z_NH_centers_ll <- st_transform(z_NH_centers, crs = 4326)

st_crs(z_NH_centers_ll)

z_NH_centers_ll_data <- cbind(st_drop_geometry(z_NH_centers_ll), 
                            st_coordinates(z_NH_centers_ll))

z_NH_centers_ll_data$NAME_fixed <- tolower(z_NH_centers_ll_data$NAME)

#### Identified a few naming issues matching city_served to shapefile, so manual fixing:

NH_nameupdates <- z_NH_centers_ll_data$NAME_fixed %>% 
  str_replace_all(c("hart's location" = "harts location", 
                  "thompson & meserve" = "thompson and meserves purchase",
                  "pinkham's grant" = "pinkhams grant", 
                  "low & burbanks" = "low and burbanks grant"))

z_NH_centers_ll_data$NAME_fixed <- NH_nameupdates

# write.csv(z_NH_centers_ll_data, 
#           "data_export/z_NH_centers_ll_data.csv", row.names = FALSE, na = "")

```


```{r}

ga_NewEng_CT_1x_df_NHgisI <- ga_NewEng_CT_1x_df %>% 
  filter(primacy_agency_code == "NH") %>% 
  inner_join(., z_NH_centers_ll_data, by = c("city_served2" = "NAME_fixed"))


watsys_noecholoc_NewEng_NHgisI <- water_system %>% filter(epa_region == "01") %>% 
  inner_join(., ga_NewEng_CT_1x_df_NHgisI, by = "pwsid")


# ensure none already in set

set_I <- c(watsys_echoloc_I_NewEng$pwsid, 
  watsys_noecholoc_NewEng_gaZC2$pwsid, 
  watsys_noecholoc_NewEng_gaCT2$pwsid)

length(set_I) == length(unique(set_I))


watsys_noecholoc_NewEng_NHgisI_2 <- watsys_noecholoc_NewEng_NHgisI %>% 
  filter(!pwsid %in% set_I)

```


*export*
```{r}
watsys_noecholoc_NewEng_NHgisI_2 %>% 
  select(primacy_agency_code.x, epa_region, pwsid, pws_type_code, 
         Y, X, city_served2) %>% 
  arrange(primacy_agency_code.x, pwsid) %>% 
  mutate(source = "NH_GIS_I", comments = "City/Town Polygon Centroid") %>% 
  select(primacy_agency_code.x, epa_region, pwsid, pws_type_code,
         Y, X, source, city_served2, comments) %>% 
  write_csv(., "data_export/watsys_noecholoc_NewEng_NHgisI_2.csv")

```



Finally what's leftover, other strategies


1. watsys_echoloc_I
2. watsys_noecholoc_NewEng_gaZC2
3. watsys_noecholoc_NewEng_gaCT2
4. watsys_noecholoc_NewEng_NHgisI

5. watsys_noecholoc_NewEng_nogeo


# END REVISION 8/5/19













```{r}

water_system %>% filter(pwsid %in% c("LA1111023", "LA1111024"))




```



*get geographic_area filtered to single city-pwsids & single zip-pwsids (deal with multiples later)*

```{r}
ga_CT_1x <- geographic_area %>% 
  filter(area_type_code == "CT") %>% 
  group_by(pwsid) %>% 
  summarise(n = n()) %>% 
  filter(n == 1) %>% 
  .$pwsid

geographic_area_CT_1x <- geographic_area %>% 
  filter(pwsid %in% ga_CT_1x, area_type_code == "CT") %>% 
  select(-c(pws_activity_code, pws_type_code, zip_code_served, end_column))

ga_ZC_1x <- geographic_area %>% 
  filter(area_type_code == "ZC") %>% 
  group_by(pwsid) %>% 
  summarise(n = n()) %>% 
  filter(n == 1) %>% 
  .$pwsid

geographic_area_ZC_1x <- geographic_area %>% 
  filter(pwsid %in% ga_ZC_1x, area_type_code == "ZC") %>% 
  select(-c(pws_activity_code, pws_type_code, city_served, end_column))

```



```{r}

watsys_ZCCTservedloc <- 
  watsys_echoloc %>% filter(!pwsid %in% watsys_echoloc_acc01$pwsid) %>% 
  left_join(., geographic_area_ZC_1x, by = "pwsid")

watsys_ZCCTservedloc <- watsys_ZCCTservedloc %>% 
  left_join(., geographic_area_CT_1x, by = "pwsid")

nrow(watsys_echoloc_acc01) + nrow(watsys_ZCCTservedloc) == nrow(water_system)

```



*next using zipcode package for zip codes served*

```{r}
data(zipcode)
colnames(zipcode) <- c("zip", "Rzcpkg_city", "Rzcpkg_state", "Rzcpkg_lat", "Rzcpkg_lon")

zipcode$Rzcpkg_city <- tolower(zipcode$Rzcpkg_city)

```


```{r}

watsys_ZCCTservedloc <- watsys_ZCCTservedloc %>% 
  left_join(., zipcode, by = c("zip_code_served" = "zip"))

```


*next using city/town data try city_served, but it needs some cleaning!*

1. leading/trailing space

2. to lower case

3. some obviously not city/town name, but join takes care of that


```{r}

watsys_ZCCTservedloc <- watsys_ZCCTservedloc %>% 
  mutate(city_served = tolower(str_trim(city_served)))

```


```{r}
watsys_ZCCTservedloc_I <- watsys_ZCCTservedloc %>% 
  left_join(., US_cities, by = c("primacy_agency_code" = "state_id", 
                                 "city_served" = "city_ascii_lwr"))
```



*because US_cities seems not so good for some (NH for one), also going back to R zip package (although it causes non-unique b/c of city/town with multiple zips)*
```{r}

watsys_ZCCTservedloc_II <- watsys_ZCCTservedloc_I %>% 
  left_join(., zipcode, by = c("primacy_agency_code" = "Rzcpkg_state", 
                                 "city_served" = "Rzcpkg_city"))

```




```{r}
watsys_ZCCTservedloc_I <- watsys_ZCCTservedloc_I %>% 
  mutate(loc_acc = case_when(!is.na(Rzcpkg_lat) ~ "acc_ZC_I", 
                             is.na(Rzcpkg_lat) & !is.na(lat) ~ "acc_CT_I"))


watsys_ZCCTservedloc_II <- watsys_ZCCTservedloc_II %>% 
  mutate(loc_acc = case_when(!is.na(Rzcpkg_lat.x) ~ "acc_ZC_I", 
                             is.na(Rzcpkg_lat.x) & !is.na(lat) ~ "acc_CT_I",
                             is.na(Rzcpkg_lat.x) & is.na(lat) & !is.na(Rzcpkg_lat.y) ~ "acc_CT_II"))

```




## SKIP UNLESS NEED NEW
## IV. Export 

```{r}


watsys_echoloc_acc01 %>% 
  select(pwsid, primacy_agency_code, primacy_type, primary_source_code, pws_name,
         pws_type_code, service_connections_count, population_served_count, 
         fac_name:fac_accuracy_meters) %>% 
  write.csv(., "data_export/watsys_echoloc_acc01.csv", row.names = FALSE, na = "")


watsys_ZCCTservedloc_I %>% 
  select(pwsid, primacy_agency_code.x, primacy_type, primary_source_code, pws_name,
         pws_type_code, service_connections_count, population_served_count, 
         fac_name:fac_accuracy_meters, area_type_code.x, zip_code_served,
         area_type_code.y, city_served, Rzcpkg_city:loc_acc) %>% 
  write.csv(., "data_export/watsys_ZCCTservedloc_I.csv", row.names = FALSE, na = "")


watsys_ZCCTservedloc_II %>% 
  select(pwsid, primacy_agency_code.x, primacy_type, primary_source_code, pws_name,
         pws_type_code, service_connections_count, population_served_count, 
         fac_name:fac_accuracy_meters, area_type_code.x, zip_code_served,
         area_type_code.y, city_served, Rzcpkg_city:loc_acc) %>% 
  filter(loc_acc == "acc_CT_II") %>% 
  write.csv(., "data_export/watsys_ZCCTservedloc_II.csv", row.names = FALSE, na = "")

watsys_ZCCTservedloc_II %>% 
  select(pwsid, primacy_agency_code.x, primacy_type, primary_source_code, pws_name,
         pws_type_code, service_connections_count, population_served_count, 
         fac_name:fac_accuracy_meters, area_type_code.x, zip_code_served,
         area_type_code.y, city_served, Rzcpkg_city:loc_acc) %>% 
  write.csv(., "data_export/watsys_ZCCTservedloc_II_all.csv", row.names = FALSE, na = "")

```

## SKIP UNLESS NEED NEW
## More location data

```{r}
library(sf)

z_NH_centers <- 
  st_read("C:/Users/Jim/Files/CFB/GIS/locations/NH/GRANIT_20190713073323/pbp_centers.shp")

st_crs(z_NH_centers)

z_NH_centers_ll <- st_transform(z_NH_centers, crs = 4326)

st_crs(z_NH_centers_ll)

z_NH_centers_ll_data <- cbind(st_drop_geometry(z_NH_centers_ll), 
                            st_coordinates(z_NH_centers_ll))

z_NH_centers_ll_data$NAME_fixed <- tolower(z_NH_centers_ll_data$NAME)

#### Identified a few naming issues matching city_served to shapefile, so manual fixing:

NH_nameupdates <- z_NH_centers_ll_data$NAME_fixed %>% 
  str_replace_all(c("hart's location" = "harts location", 
                  "thompson & meserve" = "thompson and meserves purchase",
                  "pinkham's grant" = "pinkhams grant", 
                  "low & burbanks" = "low and burbanks grant"))

z_NH_centers_ll_data$NAME_fixed <- NH_nameupdates

#### Could have used mutate w/case_when(), maybe better

# write.csv(z_NH_centers_ll_data, 
#           "data_export/z_NH_centers_ll_data.csv", row.names = FALSE, na = "")

```



```{r}

watsys_ZCCTservedloc_II %>% filter(primacy_agency_code.x == "NH", is.na(loc_acc)) %>% 
  .$pwsid %>% length()

watsys_ZCCTservedloc_II %>% filter(primacy_agency_code.x == "NH", is.na(loc_acc)) %>% 
  .$pwsid %>% unique() %>% length()


watsys_ZCCTservedloc_II %>% filter(primacy_agency_code.x == "NH", is.na(loc_acc)) %>% 
  left_join(., z_NH_centers_ll_data, by = c("city_served" = "NAME_fixed")) %>% 
  select(pwsid, primacy_agency_code.x, primacy_type, primary_source_code, pws_name,
         pws_type_code, service_connections_count, population_served_count, 
         fac_name:fac_accuracy_meters, area_type_code.x, zip_code_served,
         area_type_code.y, city_served, Rzcpkg_city:Y) %>% 
  write.csv(., "data_export/watsys_ZCCTservedloc_II_NH_GIS_I.csv", row.names = FALSE, na = "")

```



## Matching


```{r}





```




*another way using fuzzy matching?*

```{r}

```




### maybe:
<!-- ## V. Unmatched I -->

<!-- ```{r} -->
<!-- watsys_echoloc_nonzip <- watsys_echoloc %>%  -->
<!--   filter(!is.na(sdwa_ids_count), fac_accuracy_meters > 10000) -->

<!-- ``` -->


<!-- ```{r} -->
<!-- watsys_echoloc_nonzip_citymatch <- watsys_echoloc_nonzip %>%  -->
<!--   select(pwsid, primacy_agency_code, fac_city, fac_zip, fac_state) %>%  -->
<!--   mutate(fac_city = tolower(fac_city)) %>%  -->
<!--   inner_join(., US_cities, by = c("primacy_agency_code" = "state_id",  -->
<!--                                  "fac_city" = "city_ascii_lwr")) -->
<!-- ``` -->




