---
title: "CFB zipcode work"
author: "Jim Sheehan"
date: "April 3, 2019"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## 0. Load packages
```{r message=FALSE}
library(data.table)
library(readr)
library(dplyr) # some masking of data.table: between, first, last
library(ggplot2)
library(maps) # has some basic vector basemaps
library(zipcode) # for getting lat/lon coordinates where zipcode is available
# library(lubridate)
# library(noncensus) holding off for now, try ZCTA directly, can match to US Census data at that resolution


```

<br>

+ Plan on changing this to access the Google cloud database

## I. Load data

<br>

```{r}
water_systems <- fread("C:/Users/Jim/Files/CFB/JohnMeroth/SDWIS/WATER_SYSTEM.csv", 
                  sep = ",")
```

<br>

#### Small fix of column names (dropping string before "."), and dropping extra empty column:
```{r}
water_systems[, V48 := NULL]

varnames_ws <- colnames(water_systems)
head(varnames_ws)

varnames_ws <- gsub("^.*\\.","",varnames_ws)
colnames(water_systems) <- varnames_ws
# fixed variable names
cat("\n")
varnames_ws


```

<br>

#### Looking for duplicates in primary key:
```{r}
water_systems %>% 
  count(PWSID) %>% 
  filter(n > 1)

```

<br>

#### Set primary key:
```{r}
setkey(water_systems, PWSID)
key(water_systems)
```

<br>

#### Zipcode data from census zip code tabulation areas

 + ideally use these to match to demographics, etc, at a relatively fine scale
 
```{r}
# data.table seems to be harder for .zip, using readr package
zcta <- read_table2("../data/2016_Gaz_zcta_national.zip")

# empty extra column dropped
zcta <- zcta[, -8]

```

<br>

#### Zipcode data from zipcode::zipcode

 + provides some "fill-in"
 
```{r}
data(zipcode)
sum(nchar(zipcode$zip) != 5) # all 5 character length

```

<br>

#### Zipcode clean:
```{r}

# whoa, the zip codes in water_systems are messy:
unique(nchar(water_systems$ZIP_CODE))
nrow(water_systems[nchar(water_systems$ZIP_CODE) != 5 & nchar(water_systems$ZIP_CODE) > 0, ])


water_systems$ZIP_CODE5 <- substr(water_systems$ZIP_CODE, start = 1, stop = 5) 

sum(is.na(water_systems$ZIP_CODE5))

# now using zipcode clean package function (which doesn't fix >5 character zips)
# seems to remove mostly junk (zip codes "", with characters instead of #'s, etc.)
water_systems$ZIP_CODE5 <- clean.zipcodes(water_systems$ZIP_CODE5)

sum(is.na(water_systems$ZIP_CODE5))

water_systems %>% filter(is.na(ZIP_CODE5), ZIP_CODE != "") %>% 
  .$ZIP_CODE

# Fixing one "5496O" should be "54960"

water_systems <- water_systems %>% 
  mutate(ZIP_CODE5 = case_when(ZIP_CODE == "5496O" ~ "54960", 
                               TRUE ~ ZIP_CODE5))


```

<br>

#### Rename some of the columns for zipcode::zipcode prior to join

+ helps distinguish from similar SWDIS variable names, and other lat/lon sources (e.g., zipcode tabulation area centroids for comparison)
```{r}
colnames(zipcode)
colnames(zipcode) <- c("zip", "Rzcpkg_city", "Rzcpkg_state", "Rzcpkg_lat", "Rzcpkg_lon")
colnames(zipcode)

```

<br>

#### Join

+ zcta first

```{r}
merge1 <- left_join(water_systems, zcta, by = c("ZIP_CODE5" = "GEOID"))

sum(is.na(merge1$INTPTLAT))
```


+ now zipcode for NA's 

```{r}
merge1 <- left_join(merge1, zipcode, by = c("ZIP_CODE5" = "zip"))

# create merged lat/lon columns and source column


merge1 <- merge1 %>% mutate(LAT = if_else(is.na(INTPTLAT), Rzcpkg_lat, INTPTLAT), 
                            LON = if_else(is.na(INTPTLONG), Rzcpkg_lon, INTPTLONG),
                            COORD_SRC = case_when(!is.na(INTPTLAT) ~ "zcta",
                                                  is.na(INTPTLAT) & !is.na(Rzcpkg_lat) ~ "rzcpkg"))


sum(is.na(merge1$LAT))

```

<br>

#### Filter and count # w/o coordinates, by PWS_TYPE_CODE (row TRUE)

+ also # unique zipcodes

```{r}
merge1_A <- merge1 %>% filter(PWS_ACTIVITY_CODE == "A")

sum(is.na(merge1_A$LAT))

table(is.na(merge1_A$LAT), merge1_A$PWS_TYPE_CODE)

length(unique(merge1_A$ZIP_CODE5))

```

<br>

#### Export dataset

```{r}
merge1_A %>% select(PWSID, ZIP_CODE5, LAT, LON, COORD_SRC) %>% 
  write.csv(gzfile("data_export/PWSID_coordinates.csv.gz"), row.names = FALSE)

```

<br>

#### Just making sure

```{r}
checkit <- readr::read_csv("data_export/PWSID_coordinates.csv.gz")

nrow(checkit)

head(checkit)

# number of NA's, the PWSIDs that were not matched
summary(checkit$LAT)
summary(checkit$LON)

# coordinate source when present
table(checkit$COORD_SRC)

rm(checkit)

```

<br>

#### Exploring things a bit

this is nice:
https://eriqande.github.io/rep-res-web/lectures/making-maps-with-R.html

```{r fig.height=8, fig.width=8}

states <- map_data("state")

lwr48 <- state.abb[!state.abb %in% c("AK", "HI")]

# panel plot instead of together (some overlap if plot 1 on top of other)

merge1_A_CWS_48 <- merge1_A %>% filter(STATE_CODE %in% c(lwr48, "DC"), 
                                       PWS_TYPE_CODE == "CWS",
                                       GW_SW_CODE %in% c("GW", "SW"),
                                       between(LON, -130, -60 ), 
                                       between(LAT, 25, 50 ))

ggplot(data = states) + 
  geom_polygon(aes(x = long, y = lat, group = group), fill = "white", color = "gray70") + 
  geom_point(data = merge1_A_CWS_48, 
             aes(x = LON, y = LAT, color = GW_SW_CODE), size = 0.8, alpha = 0.75) +
  coord_fixed(1.3) + 
  ggtitle("Zip codes with >= 1 Active CWS by surface and ground water as primary source") + 
  scale_color_manual(values = c("purple", "orange")) + facet_wrap(~GW_SW_CODE, ncol = 1)

```

<br><br><br><br>

# END

***

*In development*

<br>

#### Counting things within a distance of zip code coordinate

```{r}

```

<br>

#### linking to demographic info (at zcta-level)
https://factfinder.census.gov/faces/tableservices/jsf/pages/productview.xhtml?pid=ACS_17_5YR_DP03&prodType=table





