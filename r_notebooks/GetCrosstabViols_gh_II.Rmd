---
title: "CFB manage violations II"
author: "Jim Sheehan"
date: "March 18, 2019"
output: github_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, strip.white = FALSE)

```

<br>

## 0. Load packages
```{r message=FALSE}
library(data.table)
library(dplyr) # some masking of data.table: between, first, last
library(ggplot2)
library(zipcode) # for getting lat/lon coordinates where zipcode is available
library(lubridate)

```

<br>

## I. Load data

<br>

+ Plan on changing this to access the Google cloud database

```{r results='hold'}

# library(readr)
# viol_all <- read_csv("VIOLATION.csv")
# read_csv too slow with big files like VIOLATION
# data.table fread() uses multiple cores
# can check first:  
# getDTthreads()

# the latest download
viol_all <- fread("C:/Users/Jim/Files/CFB/JohnMeroth/SDWIS/VIOLATION.csv", 
                  sep = ",")

orig_nrows <- nrow(viol_all)
orig_nrows
```

<br>

#### Small fix of column names (dropping string before "."), and dropping extra empty column:
```{r}
viol_all[, V35 := NULL]

varnames <- colnames(viol_all)
head(varnames)

varnames <- gsub("^.*\\.","",varnames)
colnames(viol_all) <- varnames
# fixed variable names
cat("\n")
varnames


```

<br>

#### (Fairly) quick test for duplicates: no unique row identifier column so whole thing:
```{r results='hold'}
dups_viol_all <- duplicated(viol_all)

dups_sum <- sum(dups_viol_all)
dups_sum

if(dups_sum == 0) {
  rm(dups_viol_all)
}

```

<br>

#### Looking for/at duplicates in primary (composite) key:
```{r}
viol_all %>% 
  count(PWSID, VIOLATION_ID) %>% 
  filter(n > 1)

```

<br>

#### OK, create a unique key:
```{r}
viol_all[, RowID := paste0(PWSID, VIOLATION_ID)]
setkey(viol_all, RowID)
key(viol_all)
```

<br>

#### Convert some columns to date format:
```{r results='hold'}
#### Testing to get format right
# tmpdate <- viol_all[1:10,]$COMPL_PER_BEGIN_DATE
# as.IDate(tmpdate, format = "%d-%b-%y")

viol_all[, cpbd := as.IDate(COMPL_PER_BEGIN_DATE, format = "%d-%b-%y")]
viol_all[, cped := as.IDate(COMPL_PER_END_DATE, format = "%d-%b-%y")]
viol_all[, rtcd := as.IDate(RTC_DATE, format = "%d-%b-%y")]

class(viol_all$cpbd)
summary(viol_all$cpbd)
```

*Note: max compliance period begin date way beyond present! Just a couple though: PR0004565, LA1017050*

<br>

#### Add some new columns to help create yearly timeline (later):
```{r results='hold'}
viol_all[, cpbd_year := year(cpbd)]
viol_all[, cped_year := year(cped)]

viol_all[, ydiff := cped_year - cpbd_year]

cat("Difference in years: compliance end date - begin date (some oddities)", "\n\n")
summary(viol_all$ydiff)

```

<br>

#### #*COMPLIANCE_STATUS_CODE is important for understanding violation timeline*

```{r}
unique(viol_all$COMPLIANCE_STATUS_CODE)

```

<br>

by PWS_ACTIVITY_CODE  

+ Active, Inactive, M (missing?), N (what is this?)

```{r}
table(viol_all$COMPLIANCE_STATUS_CODE, viol_all$PWS_ACTIVITY_CODE)
```

<br>

#### #*COMPLIANCE_STATUS_CODE I's have no active water systems, just need R, O, and K*

<br>

#### Filtering out COMPLIANCE_STATUS_CODE = "R" (returned to compliance), PWS_ACTIVITY_CODE = "Active", rtcd (returned to compliance date) within period of interest, and tallying by IS_HEALTH_BASED_IND

+ *compliance period begin date could also be filtered for same period, as for O and K below, but just using RTC date = a lot more PWSIDs kept. Looking at tmp, it seems compliance period begin/end dates not necessarily tied to RTC date*

<br>

+ RTC_y08y16_nHB = "returned to compliance within 2008-2016 period, non-health based violation"
+ RTC_y08y16_HB = "returned to compliance within 2008-2016 period, health based violation"


```{r}
# , between(cpbd, as.Date("2008-01-01"), as.Date("2016-12-31")) # taken out of filter

viol_RTC <- viol_all %>% filter(COMPLIANCE_STATUS_CODE == "R", PWS_ACTIVITY_CODE == "A",
                    between(rtcd, as.Date("2008-01-01"), as.Date("2016-12-31"))) %>% 
  group_by(PWSID, PWS_TYPE_CODE, PWS_ACTIVITY_CODE, IS_HEALTH_BASED_IND) %>% 
  count(name = "RTC_0816_n") %>% 
  tidyr::spread(key = IS_HEALTH_BASED_IND, value = RTC_0816_n, fill = 0) %>% 
  rename(RTC_y08y16_nHB = N, RTC_y08y16_HB = Y)

nrow(viol_RTC)
head(viol_RTC)

```

<br>

```{r}
# explore of cpbd before/after period for these
tmp <- viol_all %>% filter(COMPLIANCE_STATUS_CODE == "R", PWS_ACTIVITY_CODE == "A",
                    between(rtcd, as.Date("2008-01-01"), as.Date("2016-12-31")),
                    cpbd < as.Date("2008-01-01") | cpbd > as.Date("2016-12-31"))

length(unique(tmp$PWSID))

tmp %>% select(cpbd:rtcd, PWSID:VIOLATION_ID, 
               PWS_TYPE_CODE:CONTAMINANT_CODE) %>% 
  arrange(cpbd) %>% head(n = 10)

tmp %>% select(cpbd:rtcd, PWSID:VIOLATION_ID, 
               PWS_TYPE_CODE:CONTAMINANT_CODE) %>% 
  arrange(cpbd) %>% tail(n = 10)
```


<br>

#### Now trying to get yearly presence (including 2017)

+ This works, but should be able to use data.table::dcast for speed, maybe after using dplyr to filter and create cast column (may need setDT)
+ Should adapt to create history for particular contaminant(s), even potentially a shiny app to pick and map/export dataset (create temp local directory to hold filter first, perhaps)
+ What to do about COMPLIANCE_STATUS_CODE = K and O?

```{r results='hold'}
viol_RTC_byYear <- viol_all %>% filter(COMPLIANCE_STATUS_CODE == "R", 
                                       PWS_ACTIVITY_CODE == "A",
                    between(rtcd, as.Date("2008-01-01"), as.Date("2017-12-31"))) %>% 
  mutate(rtcd_year = year(rtcd))

  
# # old:   
# viol_RTC_byYear_x <- dcast(viol_RTC_byYear, PWSID + 
#                              PWS_TYPE_CODE + IS_HEALTH_BASED_IND ~ rtcd_year, 
#                     fun.agg = function(x) length(x), 
#                     value.var = "rtcd_year") %>% 
#   tidyr::spread(key = IS_HEALTH_BASED_IND, value = "rtcd_year")
# head(viol_RTC_byYear_x)  
  
  

viol_RTC_byYear_x <- viol_RTC_byYear %>% 
  group_by(PWSID, PWS_TYPE_CODE, IS_HEALTH_BASED_IND, rtcd_year) %>% 
  count() %>% 
  mutate(hb_year = paste("RTC_HB", IS_HEALTH_BASED_IND, rtcd_year, sep = "_")) %>% 
  ungroup() %>% 
  select(PWSID, PWS_TYPE_CODE, hb_year, n) %>% 
  tidyr::spread(key = hb_year, value = n, fill = 0)


head(viol_RTC_byYear_x)


```

#### For export if needed:
```{r}
# write.csv(viol_RTC_byYear_x, "data_export/viol_RTC_byYear0817_x.csv", row.names = FALSE)

```


#### Now for specific contaminant(s)

+ looking at their (here those starting with "3") descriptive names, etc. via join and their total count n 

```{r}
library(stringr)

contam_codes <- readr::read_csv("../data/contam.csv")

viol_RTC_byYear %>% filter(str_detect(CONTAMINANT_CODE, "^3")) %>% 
  group_by(CONTAMINANT_CODE) %>% 
  count() %>% 
  left_join(., contam_codes, by = c("CONTAMINANT_CODE" = "CODE"))


```
 
*focusing on COLIFORM (TCR) for now*

```{r}

viol_RTC_byYear_x_c <- viol_RTC_byYear %>% 
  filter(CONTAMINANT_CODE == "3100") %>% 
  group_by(PWSID, PWS_TYPE_CODE, IS_HEALTH_BASED_IND, rtcd_year) %>% 
  count() %>% 
  mutate(hb_year = paste("RTC_HB", IS_HEALTH_BASED_IND, rtcd_year, sep = "_")) %>% 
  ungroup() %>% 
  select(PWSID, PWS_TYPE_CODE, hb_year, n) %>% 
  tidyr::spread(key = hb_year, value = n, fill = 0)


head(viol_RTC_byYear_x_c)


```

+ adding some summary columns

```{r}

viol_RTC_byYear_x_c <- viol_RTC_byYear_x_c %>% 
  mutate(RTC_HB_N_sum = rowSums(.[3:12]),
         RTC_HB_Y_sum = rowSums(.[13:22]))

summary(viol_RTC_byYear_x_c[, 23:24])

cor(viol_RTC_byYear_x_c$RTC_HB_N_sum, viol_RTC_byYear_x_c$RTC_HB_Y_sum)

```

+ join to zip code-associated data

```{r message=FALSE}

sum(duplicated(viol_RTC_byYear_x_c$PWSID))

zipcoords <- readr::read_csv("data_export/PWSID_coordinates.csv.gz")

viol_RTC_byYear_x_c <- left_join(viol_RTC_byYear_x_c, zipcoords[, -2], by = "PWSID")

# viol_RTC_byYear_x_c %>% filter(is.na(ZIP_CODE5))


```


+ some exploration of State, etc. (this State from zipcode R package, may differ from SDWIS for some PWSIDs but going with for now)

```{r fig.height=9, fig.width=7}

viol_RTC_byYear_x_c %>% 
  filter(Rzcpkg_state %in% c(state.abb, "PR"), PWS_TYPE_CODE == "CWS") %>% 
  group_by(Rzcpkg_state) %>% 
  summarise(meanRTC_HB_Y = mean(RTC_HB_Y_sum), meanRTC_HB_N = mean(RTC_HB_N_sum)) %>% 
  ungroup() %>% 
  mutate(Rzcpkg_state = forcats::fct_reorder(Rzcpkg_state, meanRTC_HB_Y)) %>%
  tidyr::gather(Variable, Value, 2:3) %>% 
  ggplot(aes(x = Rzcpkg_state, y = Value, fill = Variable)) + 
  geom_bar(stat = "identity") +
  coord_flip()

```

+ data when there is at least 1 HB RTC

```{r fig.height=9, fig.width=9}

n_RTC_HB_Y <- viol_RTC_byYear_x_c %>% 
  filter(Rzcpkg_state %in% c(state.abb, "PR"), 
         PWS_TYPE_CODE == "CWS", RTC_HB_Y_sum > 0) %>% 
  group_by(Rzcpkg_state) %>% 
  summarize(x_n = n(), y_mean = mean(RTC_HB_Y_sum)) %>% 
  arrange(-y_mean)


viol_RTC_byYear_x_c %>% 
  filter(Rzcpkg_state %in% c(state.abb, "PR"), 
         PWS_TYPE_CODE == "CWS", RTC_HB_Y_sum > 0) %>% 
  ggplot(aes(x = reorder(Rzcpkg_state, RTC_HB_Y_sum, mean), y = RTC_HB_Y_sum)) + 
  geom_boxplot() +
  stat_summary(fun.y=mean, colour="darkred", geom="point", 
                           shape=18, size=3, show.legend = FALSE) +
  geom_text(data = n_RTC_HB_Y, aes(x = reorder(Rzcpkg_state, y_mean), 
                                   y = 0, label = x_n), size = 3, nudge_y = 0) + 
  coord_flip(ylim = c(1, 45))
  
```



#### Maybe focus on NE and MO, quite different sample sizes but high, good story there?










*count of PWSIDs by State that have had RTC_HB_Y over 10 year period for COLIFORM (TCR)*
```{r}
zipcoords %>% 
  filter(Rzcpkg_state %in% c(state.abb, "PR"), PWS_TYPE_CODE == "CWS") %>% 
  group_by(Rzcpkg_state) %>% 
  count() %>% arrange(-n) %>% 
  print.data.frame()  


viol_RTC_byYear_x_c %>% 
  filter(Rzcpkg_state %in% c(state.abb, "PR"), PWS_TYPE_CODE == "CWS", RTC_HB_Y_sum > 0) %>% 
  group_by(Rzcpkg_state) %>% 
  count() %>% arrange(-n) %>% 
  print.data.frame()

```





#### aggregating to zip code


```{r}


CWS_contam_byzip_dat <- viol_RTC_byYear_x_c %>% 
  filter(!is.na(ZIP_CODE5), ZIP_CODE5 != "00000", PWS_TYPE_CODE == "CWS") %>% 
  group_by(ZIP_CODE5) %>% 
  summarise(PW_n = n(), sum_RTC_NHB = sum(RTC_HB_N_sum), sum_RTC_HB = sum(RTC_HB_Y_sum))

summary(CWS_contam_byzip_dat)

min(CWS_contam_byzip_dat$sum_RTC_NHB + CWS_contam_byzip_dat$sum_RTC_HB) # has to be >= 1

```





```{r}
Zips_CWS_A_sp_main_TAM <- readRDS("data_export/Zips_CWS_A_sp_main_TAM.rds")

# zipcoords_dat <- zipcoords %>% filter(PWS_TYPE_CODE == "CWS", !is.na(ZIP_CODE5)) %>% 
#   group_by(ZIP_CODE5) %>% 
#   count() %>% 
#   left_join(., Zips_CWS_A_sp_main_TAM@data, by = "ZIP_CODE5") %>% 
#   rename(Tot_PW_n = n)
# 
# summary(zipcoords_dat)
# 
# CWS_contam_byzip_dat <- left_join(zipcoords_dat, CWS_contam_byzip_dat, by = "ZIP_CODE5")
# 
# CWS_contam_byzip_dat <- left_join(CWS_contam_byzip_dat, zipcode, by = c("ZIP_CODE5" = "zip"))

```



```{r}
# CWS_contam_byzip_datII <- CWS_contam_byzip_dat %>% ungroup() %>% 
#   filter(!is.na(LAT))
# 
# CWS_contam_byzip_datII[, 6:8] <- lapply(CWS_contam_byzip_datII[, 6:8], function(x) ifelse(is.na(x), 0, x))
# 
# summary(CWS_contam_byzip_datII)

```



```{r}

plot(CWS_contam_byzip_datII$sum_RTC_NHB, CWS_contam_byzip_datII$PW_n)
plot(CWS_contam_byzip_datII$sum_RTC_HB, CWS_contam_byzip_datII$PW_n)

```

*this is not good modeling approach*
```{r}
model1 <- lm(sum_RTC_HB ~ TAM + PW_n + Rzcpkg_state, data = CWS_contam_byzip_datII)
plot(model1)

```

```{r}
model2 <- glm(sum_RTC_HB ~ TAM + PW_n + Rzcpkg_state, data = CWS_contam_byzip_datII, 
              family = poisson())
summary(model2)
plot(model2)
```


```{r}

CWS_contam_byzip_datII[c(18080, 16560, 3325, 392), ]

model2a <- glm(sum_RTC_HB ~ TAM + PW_n, data = CWS_contam_byzip_datII[-c(18080, 16560, 3325, 392), ], 
              family = poisson())
model2a
plot(model2a)
```


```{r}

hist(CWS_contam_byzip_datII$sum_RTC_NHB)
hist(CWS_contam_byzip_datII$sum_RTC_HB)

hist(CWS_contam_byzip_datII$Tot_PW_n)

hist(CWS_contam_byzip_datII$PW_n)

hist(CWS_contam_byzip_datII$TAM / 10)

```

#### need to wrangle data more/apply a different model

```{r}
CWS_contam_byzip_datII %>% mutate()
```








<br>


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


***



<br>

#### Filtering out COMPLIANCE_STATUS_CODE = "O" (open violation), PWS_ACTIVITY_CODE = "Active", cpbd (compliance period begin date; these have no end date or rtc date) within period of interest, and tallying by IS_HEALTH_BASED_IND

+ O_y08y16_nHB = "Open violation within 2008-2016 period, non-health based violation"
+ O_y08y16_nHB = "Open violation within 2008-2016 period, health based violation"


```{r}
viol_O <- viol_all %>% filter(COMPLIANCE_STATUS_CODE == "O", PWS_ACTIVITY_CODE == "A",
                    between(cpbd, as.Date("2008-01-01"), as.Date("2016-12-31"))) %>% 
  group_by(PWSID, PWS_TYPE_CODE, PWS_ACTIVITY_CODE, IS_HEALTH_BASED_IND) %>% 
  count(name = "O_0816_n") %>% 
  tidyr::spread(key = IS_HEALTH_BASED_IND, value = O_0816_n, fill = 0) %>% 
  rename(O_y08y16_nHB = N, O_y08y16_HB = Y)

nrow(viol_O)
head(viol_O)

```



<br>

#### Filtering out COMPLIANCE_STATUS_CODE = "K" (known: not really sure what this is yet), PWS_ACTIVITY_CODE = "Active", cpbd (compliance period begin date; these have end dates - some later than period, but not sure how/if to use, and no rtc date) within period of interest, and tallying by IS_HEALTH_BASED_IND

+ K_y08y16_nHB = "Known within 2008-2016 period, non-health based violation"
+ K_y08y16_nHB = "Known within 2008-2016 period, health based violation"


```{r results='hold'}
viol_K <- viol_all %>% filter(COMPLIANCE_STATUS_CODE == "K", PWS_ACTIVITY_CODE == "A",
                    between(cpbd, as.Date("2008-01-01"), as.Date("2016-12-31"))) %>% 
  group_by(PWSID, PWS_TYPE_CODE, PWS_ACTIVITY_CODE, IS_HEALTH_BASED_IND) %>% 
  count(name = "K_0816_n") %>% 
  tidyr::spread(key = IS_HEALTH_BASED_IND, value = K_0816_n, fill = 0) %>% 
  rename(K_y08y16_nHB = N, K_y08y16_HB = Y)

head(viol_K)

# weird, just 1: 
sum(viol_K$V1)
# it's VI3000052, blank for IS_HEALTH_BASED_IND, dropping

viol_K <- viol_K %>% select(-V1)

nrow(viol_K)
head(viol_K)

```

<br>

#### Load new water system .csv:
```{r}
water_systems <- fread("C:/Users/Jim/Files/CFB/JohnMeroth/SDWIS/WATER_SYSTEM.csv", 
                  sep = ",")
```

<br>

#### Small fix of column names (dropping string before "."), and dropping extra empty column:
```{r}
water_systems[, V48 := NULL]

varnames_ws <- colnames(water_systems)
head(varnames_ws)

varnames_ws <- gsub("^.*\\.","",varnames_ws)
colnames(water_systems) <- varnames_ws
# fixed variable names
cat("\n")
varnames_ws


```

<br>

#### Looking for duplicates in primary key:
```{r}
water_systems %>% 
  count(PWSID) %>% 
  filter(n > 1)

```

<br>

#### Set primary key:
```{r}
setkey(water_systems, PWSID)
key(water_systems)
```

<br>

#### Join preliminaries:
```{r results='hold'}
setDT(viol_RTC)
length(unique(viol_RTC$PWSID)) == nrow(viol_RTC)
setkey(viol_RTC, PWSID)
key(viol_RTC)

setDT(viol_O)
length(unique(viol_O$PWSID)) == nrow(viol_O)
setkey(viol_O, PWSID)
key(viol_O)

setDT(viol_K)
length(unique(viol_K$PWSID)) == nrow(viol_K)
setkey(viol_K, PWSID)
key(viol_K)

```

<br>

#### Joining and filling in NA with 0:
```{r}
water_systems_A <- water_systems[PWS_ACTIVITY_CODE == "A"]
  
merge1 <- merge(water_systems_A, 
                viol_RTC[, c("PWSID", "RTC_y08y16_HB", "RTC_y08y16_nHB")], all.x = TRUE)

merge1 <- merge(merge1, 
                viol_O[, c("PWSID", "O_y08y16_HB", "O_y08y16_nHB")], all.x = TRUE)

merge1 <- merge(merge1, 
                viol_K[, c("PWSID", "K_y08y16_HB", "K_y08y16_nHB")], all.x = TRUE)

merge1[, c("RTC_y08y16_HB", "RTC_y08y16_nHB", 
           "O_y08y16_HB", "O_y08y16_nHB", 
           "K_y08y16_HB", "K_y08y16_nHB")] <- 
  lapply(merge1[, c("RTC_y08y16_HB", "RTC_y08y16_nHB", 
           "O_y08y16_HB", "O_y08y16_nHB", 
           "K_y08y16_HB", "K_y08y16_nHB")], function(x) ifelse(is.na(x), 0, x))

```

<br>

#### For export if needed:
```{r}
# merge1 %>% select(PWSID, RTC_y08y16_HB:K_y08y16_nHB) %>% 
#   write.csv("data_export/ComplianceActivity_y08y16.csv", row.names = FALSE)

```

<br>


#### Create binary version:
```{r}
merge1_binary <- merge1 %>% 
  mutate_at(vars(RTC_y08y16_HB:K_y08y16_nHB), function(x) ifelse(x > 0, 1, 0))

```

<br>

#### Summary of the number of water systems out of total for a state (plus DC & PR) that had a health based violation and returned to compliance over the 2008-2016 period:
```{r}
merge1_binary %>% filter(PWS_TYPE_CODE == "CWS", STATE_CODE %in% c(state.abb, "DC", "PR")) %>% 
  count(STATE_CODE, RTC_y08y16_HB) %>% 
  group_by(STATE_CODE) %>% 
  tidyr::spread(key = RTC_y08y16_HB, value = n, sep = "_") %>% 
  mutate(Total = RTC_y08y16_HB_0 + RTC_y08y16_HB_1, 
         Prop_RTC_y08y16_HB_1 = round(RTC_y08y16_HB_1/Total, 2)) %>% 
  arrange(desc(Prop_RTC_y08y16_HB_1))

```


<br><br><br><br>


